# ECSS

Avoiding common styling problems is simple. And you only need Efficient CSS. Nothing more.

ECSS sets simple rules for simple styling. No more naming everything, no more technological dependencies. Only intentional, consistent, simple, expressive, predictable, sustainable CSS.

Want help enforcing rules? Download the Stylelint config to nudge you and your team into ECSS.
Eager to build something? Download the ECSS scaffolding library for quick & efficient starting point.
Want to know the beast? Dive into ECSS principles and documentation.
Curious about it all? Well, keep scrolling!

## Why ECSS?

Because CSS as a language is misunderstood and undeservedly maligned. Because simple rules and low impact tools can go a long way in making sure the CSS codebase is light, simple and scalable. ECSS is a global approach to producing efficient design systems with CSS.

## ECSS values

### Intentionality

Clear objectives, rational decisions.

Every parcel of CSS has an objective. This objective should be clear to anyone reading the code. Be it HTML or CSS. Selectors are the perfect vehicle for intentionality. ECSS incentivizes the use of rational selectors.

### Consistency

Repeating patterns save time & energy.

Flexible naming guidelines give the codebase a consistency encouraging standardization and reuse. Prefixes and usage guidelines enforced through linting insures everyone on your team will follow ECSS rules.

### Simplicity

"Simple" is writing less code & and limiting dependencies.

Class soup & divitis aren't simple. Untold numbers of media queries aren't either. But modern CSS is. By accepting CSS for what it is (a designing language!) you can do *a lot* of styling mileage with very little code.

### Expressivity

Code that speaks for itself is actually achievable.

"thumbnail as-circle with-border" is instantly understandable while "h-10 w-10 bdr-50 br-1 overh" is not. Code should communicate information. The clearer the information, the easier it is to understand the system. Mistaken semantics should give way to expressiveness. Expressive best practices work.

### Predictability

Using simple but consistent authoring rules leads to predictability.

It feels good to dive into unknown code... while already knowing what it looks like. Consistency, repeating patterns, simplicity (yes, again) all coalesce into predictable code. And predictable code means less stress, less friction and happier teams!

### Sustainability

Vanilla CSS is future ready. In practice it means being at the forefront of progress and evolution. No need to wait for third parties to implement new features. You can use clamp() as of now and say goodbye to 80% of your media queries. No more "sm-this md-that". Only clean and modern code.

## Guiding principles

1. **CSS is a *designing* language, not a programming one.** And as such, its authoring should reflect *design* patterns, concepts and perspectives. With scales, tokens, global rules (sorry) you limit repetition and facilitate future styling extension.
2. **Empowering designers (code-savvy or not!) to refine their work autonomously, in the browser, is efficient.** Making the needed parts of CSS being intelligible to designers cuts stress, time and promotes good allocation of human resources, making for a great vector of economic profitability.
3. **Not all CSS properties are equal.** `display`, `position` & the box-model properties are extremely sensitive and potentially way more damaging than, say, color or type ones. The former are the stuff of professional CSS authors and the latter are the ones designers should be able to use and modify in context.
4. **Properties & units have specific roles and usage.** Limiting their use to these roles enhances clarity and promotes consistency as well as predictability. The same goes for units. Some suggest type, others, images or rhythm. Use them intentionally & rationally to communicate meaning.
6. **Components and patterns *need* structure.** Trying to abstract it away is vain. Instead, documentation and respect are key. HTML is semantically rich, so choose the right tags and refrain from changing them for superficial reasons. One would not remove or change `class="header"` without understanding its purpose first, then one should not change or remove `<header>` on a whim either.
6. **CSS Selectors are vehicles for intention.** Every selector particle must have a purpose and if not, must be discarded with. This extraneous « div » in « .card div h2 » is what makes CSS brittle. These are *not* "best practices".
7. **Selector types all have a function.** Each one of them may be of use in a certain context. No absolute usage rule should be edicted. It's not "always" or "never" but "it depends" and "why". Absolute rules absolutely corrupt. Or something like this.
8. **Selection specificity should be harnessed, not rejected.** Nevertheless, "always" (ahem) keep it as low as possible. Yes, in 2015 it may have not been easy. But it's 2023 and lots of new and widely supported features have been released. Use them.
9. **Global scope in CSS is not a sin.** Remember, CSS is a designing language and the global scope fits perfectly in design's fundamentally layered, dimensional approach. Programming best practices are not necessarily designing best practices. Embrace design best practices.
8. **Global design rules must be largely anonymous & unqualified.** Only a few rules per ruleset only. We are talking rhythm, typography, color; not `display` or `position`. *This* is the way of limiting repetition, bloat & complexity.
9. **One should wait until a concept is clearly understood before naming it.** Until then use HTML elements. Premature abstraction or "solving problems not yet encountered" are bigger problems than the use of "header" in CSS. Yes, these are programming best practices. But who told you development was pure?
10. **When more than 3 rules are repeated more than 3 times, a concept *is* emerging.** Rules should then be concentrated by naming and using said concept instead of the bare rules. Reusability, expressivity and simplicity are then greatly improved.
11. **Named concepts should be autonomous and self-sufficient.** As such, named concepts should not be defined inside another named concept. If it ever is necessary, the child concept must be scoped to the parent concept and is *not* to be reused anywhere else.
12. **Manipulating named concepts throughout multiple files is strictly prohibited.** All rules for a named concept must reside in the same, unique CSS file. For authors and maintainers to have confidence in the system, there must a single source of truth https://en.wikipedia.org/wiki/Single_source_of_truth for any concept.
13. **State, variant or structural concepts must be namespaced and prefixed.** These concepts may be represented as child or combined classes. Never to be used alone, always with a master or parent concept. Yes, here are both "never" *and* "always" in the same sentence. "Double jeopardy, we are fine".
14. **Namespaced classes should generally be implemented with specificity reducing selectors.** Unless otherwise needed, one should strive to keep specificity at 21 or below. With a preference for around 10 to 12. Modern and widely supported pseudo-selectors must here be used.
15. **One may not come up at first with the efficient way to select interface elements.** One's intention may not be clear at the beginning of a styling job. Instead of fruitlessly trying and trying, a code "quarantine" file should be temporarily used until the right selection manifests itself. Still, no quarantine file should ever be published publicly.
16. **HTML should be as simple and expressive as can be.** Refrain from over-containing, don't use "div" where you could use "aside". Dont wrap your single-level navigation in unordered lists. And yes, simple navigation is [accessible](https://dockyard.com/blog/2019/11/29/using-nav-without-a-list-element). Keep it simple... Suzy.
17. **Any HTML element should endorse one role only.** As per the famous programming [best practice](https://en.wikipedia.org/wiki/Single-responsibility_principle) (again, programming in designing), semantic tags are for... semantics whilst `div` or `span` tags are for graphical or logical division. Any type of grid should be implemented with `div` tags.
18. **Any media query adaptation must be included in its related concept's definition.** Not as as a separate file, not as suffixed classes. If one uses utility classes, the provided rules should not be query dependent but rather be universally needed, in every media configuration.
19. **Whole stylesheets are better used when global.** Media query scopes should be used in HTML `link` tags to promote reuse, performance and optimization concerns. Each fundamental design layer should be autonomous, independent and removable.
20. **Component styling should only be served with live components.** Not as a big minified file in the `head` tag of the document. This way, the infamous problem of loading unused CSS is practically solved, without any technological debt. First render is also faster since only what is used is processed by the browser. (gives CSS file path in component file)
21. **One should make full use of freely available development tools by going with the grain of the Web platform.** By using "just-in-time" rulesets, the cascade and intentional selection, the debugging workflow is simpler, lighter and clearer.
22. **Eschewing technological abstractions like high-level frameworks spurs lighter, simpler native code.** By writing native CSS, one uses CSS better; by writing HTML, one writes HTML better.

## Authoring rules

[TODO] : link all rules to related principles. Vérifier les liens numérotés.
[TODO] : add consistency principle [x] and others needed for rules
[TODO] : why, when (do & dont ou exemple détaillé, exceptions)

### All component selectors must start with its filename. (see #11, #12)

#### Example

```
/* given card.css */

/* Do */
.card {}

/* Don't */
.small-card {}
```

### All paddings must first be uniform and then be modified if necessary. (see #4)

Do
.card {
    padding: 20px;
    padding-top: 30px;
}

Don't
.card {
    padding: 30px 20px 20px 20px;
}

### Paddings are to be applied on containing and interactive elements only.

#### Example

Do
.card header {
    padding: 10px;
}

Don't
.card h2 {
    padding: 10px;
}

! ### Only vertical margins should be applied to content elements. (see #4, #17)

#### Example

Do
.card p {
    margin-top: 20px;
    max-width: 20ch;
}

Don't
.card p {
    margin-left: 40px;
    margin-right: 40px;
}

### Typographic elements should use heritage when possible. (see #4, #9)

#### Example

Do
html {
    line-height: 1.2;
}

p {
    line-height: inherit;
}

Don't
p {
    line-height: 1.2;
} 

### Design tokens should be used for most numerical values.

#### Example

Do
.card {
    padding: var(--small-spacing);
}

Don't
.card {
    padding: 20px;
}

### Repeating default rules is discouraged. ~~Any instance should be justified.~~

#### Example

Do
.dropdown:not(:hover) {
    display: none;
}

Don't
.dropdown {
    display: none;
}

.dropdown:hover {
    display: block;
}

### All class entities besides components must be prefixed. (see #13)

#### Example

Do
.card.as-circle {
    width: 20px;
}

Don't
.card.circle {
    width: 20px;
}

### Nesting is restricted to one level only.

Do
.card {
    & header p {
        color: grey;
    }
}

Don't
.card {
    & header {
        & p {
            color: grey;
        }
    }
}

### The use of specific dimensions should be avoided.

#### Example

Do
.card {
    max-width: 30ch;
}

Don't
.card {
    width: 30ch;
}

### Use attribute selectors to convey unicity.

#### Example

Do
[id="main"] {
    max-width: 80ch;
}

Don't
#main {
    max-width: 80ch;
}

### The use of positioning and display rules should minimized. (see #3)

#### Example

Do
.card>div {
    display: flex;
}

Don't
.card div {
    display: flex;
}

### Overqualified selectors are discouraged.

#### Example

Do
.card {
    color: red;
}

Don't
article.card {
    color: red;
}

### Components cannot exert outside influence. (see #11)

#### Example

```
Do
.as-pile>*+* {
    margin-top: 20px;
}

Don't
.card {
    margin-top: 20px;
}
```

### Overflow should not be hidden.

#### Example

Do
.container {
    max-height: 50dvh;
    overflow: auto;
}

Don't
.container {
    max-height: 50dvh;
    overflow: hidden;
}


### Numbers in class names are to be avoided.

#### Example

Do
.card {
    color: grey;
    font-size: 18px;
}

.card.as-featured {
    color: red;
    font-size: 20px;
}

Don't
.card {
    color: grey;
    font-size: 18px;
}

.card-1 {
    color: red;
    font-size: 20px;
}


### Magic numbers must be avoided or explained in a line comment.

#### Example

Do
.card {
    line-height: var(--line-tight);
}

Don't
.card {
    line-height: 17px;
}


! ### Entities can't be included in the not() selector.

#### Example

Do
.


### Rhythm must be applied in one direction only, preferably top. (see #4)

#### Example

```
Do
.as-pile>*+* {
    margin-top: 20px;
}

Don't 
.as-pile>* {
    margin-top: 20px;
    margin-bottom: 20px;
}
```

### The use of problematic units is discouraged. (see #6)

#### Example

Do
nav {
    max-height: 100dvh;
}

Don't
nav {
    max-height: vh;
}

### Tag selectors should be leveraged inside components. (see #5)

#### Example

```
Do
.card header {
    padding: 20px;
}

Don't
.card .card__header {
    padding: 20px;
}
```

### One entity per file with a soft cap of about a hundred lines. (see #11, #20)

#### Example

```
Do
/* card.css */
.card {
    padding: 20px;
}

/* .metainfo.css */
.metainfo {
    color: grey;
}

Don't
/* card.css */
.card {
    padding: 20px;
}

.metainfo {
    color: grey;
}
```

### Selectors must strictly include only necessary selection parts. (see #6, #8)

#### Example

Do
.card p {
    font-size: 14px;
}

Don't
.card div p {
    font-size: 14px;
}

### Duplication of a set of more than 3 rules is discouraged. (see #10)

#### Example

```
Do
/* button.css */
.button {
    padding: 10px;
    color: white;
    background-color: grey;
    border: 1px solid black;
}

Don't
/* card.css */
.card a {
    padding: 10px;
    color: white;
    background-color: grey;
    border: 1px solid black;
}

/* post.css */
.post button {
    padding: 10px;
    color: white;
    background-color: grey;
    border: 1px solid black;
}
```

### The use of the global scope is encouraged for all fundamental design layers. (see #1, #2, #9)

#### Example

```
Do
/* rhythm.css */
p+p {
    margin-top: 20px;
}

Don't
/* post.css */
.post p+p {
    margin-top: 20px;
}

/* prose.css */
.prose p+p {
    margin-top: 20px;
}
```

### HTML structure should be as flat as possible and bereft of single tag nesting. (see #4, #8, #16, #17)

#### Example

Do
<article>
    <header></header>
    <footer></footer>
</article>

Don't
<article>
    <div>
        <header></header>
        <footer></footer>
    </div>
</article>

! ### Rulesets should be auto-sufficient and avoid implicit but necessary rules. (see #11, #12)


### Specificity must be kept as low as possible. (see #8)

#### Example

Do
.card :where(h1, h2, h3, h4, h5, h6) {
    font-size: 24px;
}

Don't
.card :is(h1, h2, h3, h4, h5, h6) {
    font-size: 24px;
}


#### Caveat

Sometimes it makes sense to add specificity. But don't do it until proven necessary.


## Related tools

Browser Inspector (debugging, experimenting and navigating)
Scaffolding & code library (use it... or not!)
Stylelint (lint and inform)
CSSCSS (find rule duplication in your codebase)
PurifyCSS, PurgeCSS or Chrome Coverage devtool
